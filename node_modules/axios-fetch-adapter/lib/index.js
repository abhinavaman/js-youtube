'use strict';var fetchAuth=require('axios/lib/adapters/adapterHelper').fetchAuth,settle=require('axios/lib/core/settle'),url=require('url'),buildURL=require('axios/lib/helpers/buildURL'),createError=require('axios/lib/core/createError'),isURLSameOrigin=require('axios/lib/helpers/isURLSameOrigin'),utils=require('axios/lib/utils'),cookies=require('axios/lib/helpers/cookies');/**
 * @typedef {object} AdapterResponse
 * @property data {object} is the response that was provided by the server
 * @property status {number} is the HTTP status code from the server response
 * @property statusText {string} is the HTTP status message from the server response
 * @property headers {array} the headers that the server responded with
 * @property config {object} is the config that was provided to `axios` for the request
 * @property request {object} is the request that generated this response. It is the last request instance in redirects.
 *//**
 * typedef {object} AuthConfig
 * @property username {string}
 * @property password {string}
 *//**
 * @typedef {object} AdapterConfig
 * @property {string} url  is the server URL that will be used for the request.
 * @property params {object} are the URL parameters to be sent with the request
 * @property paramsSerializer {function({{object}}:string} an optional function in charge of serializing `params`
 * @property method {string} is the request method to be used when making the request
 * @property transformRequest {function} is the data to be sent as the request body
 *      Only applicable for request methods 'PUT', 'POST', and 'PATCH'
 *      When no `transformRequest` is set, must be of one of the following types:
 *      - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
 *      - Browser only: FormData, File, Blob
 *      - Node only: Stream, Buffer
 * @property data {object} is the data to be sent as the request body.
 *    This is only applicable for request methods 'PUT', 'POST', and 'PATCH'.
 *    When no `transformRequest` is set, must be of one of the following types:
 *      - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
 *      - Browser only: FormData, File, Blob
 *      - Node only: Stream, Buffer
 * @property headers {object} are custom headers to be sent
 * @property withCredentials {boolean} indicates whether or not cross-site Access-Control requests, only browser
 * @property xsrfCookieName {string} is the name of the cookie to use as a value for xsrf token (default: 'XSRF-TOKEN'). only browser and withCredentials=true
 * @property xsrfHeaderName {string} is the name of the http header that carries the xsrf token value (default: 'X-XSRF-TOKEN'). only browser and withCredentials=true
 * @property auth {AuthConfig} indicates that HTTP Basic auth should be used, and supplies credentials.
 * @property timeout {number} specifies the number of milliseconds before the request times out. If the request takes longer than `timeout`, the request will be aborted.
 * @property responseType {'arraybuffer'|'blob'|'document'|'json'|'text'|'stream'} indicates the type of data that the server will respond with.
 * @property cancelToken {CancelToken} specifies a cancel token that can be used to cancel the request
 *//**
 * Parse response body and returns adapter result
 *
 * @param config {AdapterConfig}
 * @param request {Request}
 * @param response {Response}
 * @returns {Promise.<AdapterResponse>}
 */function responseParser(a,b,c){function d(d){var e={};// Copy response headers to object
return c.headers.forEach(function(a,b){e[b]=a}),{data:d,status:c.status,statusText:c.statusText,headers:e,config:a,request:b}}if('arraybuffer'===a.responseType)return c.arrayBuffer().then(function(a){return d(a)});//
// TODO: when responseType is document, what should be returned?
//
// config.responseType is 'document' or 'text'
//
return'blob'===a.responseType?c.blob().then(function(a){return d(a)}):'json'===a.responseType?c.json().then(function(a){return d(a)}):'stream'===a.responseType?Promise.resolve(d(c.body)):c.text().then(function(a){return d(a)})}/**
 * Setups request headers based on options
 *
 * @param request {Request}
 * @param config {AdapterConfig}
 */function setupRequestHeaders(a,b){// Remove the default value for 'content-type' header
a.headers.get('content-type')&&a.headers.delete('content-type'),utils.forEach(b.headers,function(c,d){d.toUpperCase()==='content-type'.toUpperCase()&&(b.data===void 0||utils.isFormData(b.data))||a.headers.append(d,c)}),b.data===void 0||a.headers.has('content-type')||a.headers.set('content-type','application/json')}/**
 * Add xsrf header
 * This is only done if running in a standard browser environment.
 * Specifically not if we're in a web worker, or react-native.
 *
 * @param request {Request}
 * @param config {AdapterConfig}
 */function setupXsrfHeader(a,b){if(utils.isStandardBrowserEnv()){// Add xsrf header
var c=(b.withCredentials||isURLSameOrigin(b.url))&&b.xsrfCookieName?cookies.read(b.xsrfCookieName):void 0;c&&a.headers.set(b.xsrfHeaderName,c)}}/**
 * Setup Authorization header
 *
 * @param request {Request}
 * @param config {AdapterConfig}
 */function setupAuthHeader(a,b){var c=url.parse(b.url),d=fetchAuth(b.auth,c.auth);d&&a.headers.set('Authorization',d)}/**
 * Setup cancellation token and timeout token
 *
 * NOTE: Chrome does not support AbortController, and needs polyfill
 *
 * @param request {Request}
 * @param config {AdapterConfig}
 */function setupTimeoutAndCancellationToken(a,b){var c=AbortController?new AbortController:null;c&&(a.signal=c.signal,b.timeout&&setTimeout(function(){c.abort()},b.timeout),b.cancelToken&&b.cancelToken.promise.then(function(){c.abort()}))}/**
 * Handles dispatching a request and settling a returned Promise once a response is received.
 *
 * @param config {AdapterConfig}
 * @returns {Promise.<AdapterResponse>}
 */function fetchAdapter(a){var b=new Request(buildURL(a.url,a.params,a.paramsSerializer),/** @type RequestInit **/{method:a.method.toUpperCase(),body:a.data,credentials:a.withCredentials?'include':'omit',redirect:'manual',mode:'cors'});return setupAuthHeader(b,a),setupXsrfHeader(b,a),setupRequestHeaders(b,a),setupTimeoutAndCancellationToken(b,a),fetch(b).catch(function(){return Promise.reject(createError('Network Error',a,null,b))}).then(function(a){if(!a.body)return Promise.resolve(a);var b=a.body.getReader(),c=0;return new Promise(function(d,e){function g(){b.read().then(function(b){var e=b.done,f=b.value;return e?void d(a):void(c+=f.byteLength,console.error('received ',f.byteLength,' bytes (',c,' bytes in total)'),g())}).catch(function(a){console.error(a,a.message),e()})}g()})}).then(function(c){return responseParser(a,b,c)}).then(function(a){return new Promise(function(b,c){settle(b,c,a)})})}module.exports=fetchAdapter;